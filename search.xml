<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Caffe "in-place" operation]]></title>
    <url>%2F2018%2F11%2F29%2Fcaffe_inplace%2F</url>
    <content type="text"><![CDATA[在学习Caffe model中关于Layers内容时，发现一个问题，ReLU层的top blob和bottom blob相同，如下：123456layer &#123; name: &quot;conv2/relu_3x3_reduce&quot; type: &quot;ReLU&quot; bottom: &quot;conv2/3x3_reduce&quot; top: &quot;conv2/3x3_reduce&quot;&#125; 后来查资料发现这是caffe的in-place操作，是为了节省内（显）存，以及省去反复申请和释放内存的时间。 bottom blob和top blob名称相同，说明是同一个blob，占用的是内存的同一块空间。在这里也就是说，该ReLU操作是对输入blob本身进行操作，再将其输出。 如果定义的两个layer的top blob名称是一样的，那么这两个layer的bottom blob也一定是该top blob，并且按layer的定义顺序对该bottom blob进行操作。如果layer不是对bottom blob本身进行操作，那么top blob就不能与bottom blob相同，也不允许多个layer的top blob同名。因为假如这样做，后运算的layer会将top blob覆盖成其运算的结果，前面的layer的运算结果就消失了。 convolution、pooling层由于输入输出的size一般不一致，所以不能支持in-place操作；而ReLU函数是逐个对元素进行计算，不该变size，所以支持。AlexNet、VGGnet等都是在ReLU层使用in-place计算，ResNet中，BatchNorm和Scale也都使用了in-place计算。 目前已知支持in-place的有：ReLU层、Dropout层、BatchNorm层、Scale层。(除此之外，其他大部分layer貌似在定义时name和top是相同的。)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Yolov3 Network Architecture]]></title>
    <url>%2F2018%2F11%2F28%2Fyolov3%2F</url>
    <content type="text"><![CDATA[贴一张Yolov3网络结构图~ filter = 3*(80+1+4) = 255 Yolov3 is a fully convolutional network. It has 75 convolutional layers, with skip connections and upsampling layers. No form of pooling is used, and a convolutional layer with stride 2 is used to downsample the feature maps, which helps in preventing loss of low-level features often attributed to pooling. 详细内容见：A Closer Look at YOLOv3]]></content>
  </entry>
  <entry>
    <title><![CDATA[Some notes for deep learning]]></title>
    <url>%2F2018%2F11%2F27%2Fnotes_for_dl%2F</url>
    <content type="text"><![CDATA[Object localization监督学习训练样本中给出bounding box的中心点坐标和长宽，bx,by,bw,bhNeed to output bx,by,bw,bh,class label and Pc(is there any object?存在物体的置信度。当不存在物体的时候，loss函数只需计算Pc的准确度，其他项都不用考虑)。Y的维数为（1+4+class labels)。 Landmark detection特征点检测 需要输出一个是否有物体的置信度Pc,以及每个特征点的（x,y）坐标，所有训练集样本需包含这些labels。 面部表情识别，人体关键点检测。 Object detectionsliding windows训练：根据滑动窗口的大小，使用适当裁剪的训练集样本，训练是否图片中有需要检测的物体物体。检测：滑动窗口目标检测，对每一个窗口做一次检测，得到一个label,直到遍历图像每个区域。缺点：computation expensive。步幅大时，粗粒度会影响检测性能，无法准确定位；细粒度或小步幅时计算成本高。所以一般使用简单的线性分类器。 convolutional implementation of sliding windowsTurning FC layer into convolutional layers没有全连接层时，输入图片的大小可以改变。该卷积操作的原理是：不需要将需检测的输入图片分割成滑窗的大小的子集，分贝执行前向传播；而是直接将图片输入给卷积网络，其中的公共区域可以共享很多计算，一次性输出所有检测值。但边界框位置可能不够准确。 bounding box predictionYOLO algorithm 一个格子只存在一个物体时用一个网格划分输入图片（33）Labels for training for each grid cell:置信度Pc，bx,by,bw,bh, class labels将物体分配给中心所在的格子(训练集中该格子的Pc=1)output dimension:(1+4+class labels)\3*3,bx,by,bw,bh are specified relative to the grid cell(bbox中心所在cell的左上角坐标为0，右下角为1，bx,by是相对（0,0)的偏移量，值在0到1之间；bw,bh是bbox的长宽与grid cell边长的比值，可大于1。可以用sigmoid等函数处理，使其位于0到1之间） Intersection over Union“Correct” if IoU&gt;=0.5(human chosen)the predicted bbox with the ground truth(prior bbox) Non-max Suppresion确保每个物体只被检测出一次。先去掉所有Pc小于一定阈值的边界框(认为没有检测到物体），找出检测结果中Pc最大的bbox,然后去掉与其IoU大于阈值的检测框；再选择剩下的bbox中概率最高的…直到处理完所有框。如果图像中有多中类别的物体，应该分别对每种label各独立做一次NMS。 Anchor box使一个grid cell可以检测出多个物体。 Previously:each object in training image is assigned to grid cell that contains that object’s midpoint. With anchor boxes:each object in training image is assigned to grid cell that contains object’s midpoint and anchor box for the grid cell with highest IoU. match with (grid cell, anchor box). for each grid cell, the output Y dimension is (1+4+class labels)*anchor boxes. use k-means algorithm to choose anchor box. grid cells越多，一个cell中出现多个物体的可能性更小。 Region proposal network(RPN)two stages利用图像分割算法，选出候选区域，在每种色块(blobs)上跑分类器。先找出可能的2000个色块，然后在这些色块上放置bbox，在这些色块上跑分类器。 R-CNN: Propose regions. Classify proposed regions one at a time. Output label + bounding box. Fast R-CNN: Propose regions. Useconvolution implementation of sliding windows to classify all the proposed regions. Faster R-CNN: Use convolutional network to propose regions.]]></content>
  </entry>
  <entry>
    <title><![CDATA[目标检测模型评估指标:mAP]]></title>
    <url>%2F2018%2F11%2F24%2FmAP%2F</url>
    <content type="text"><![CDATA[这些天看论文很多处用到mAP，一直只是知道这是一个评估指标，但具体怎么得来的不太清楚，现在有空学习一下~ Mean Average Precision(mAP)用于评估目标检测模型的物体分类和定位性能，由于该类问题中每一个图片都可能包含许多不同类别的物体，故图像分类问题的标准指标precision并不适用。 Ground Truth 对于目标检测问题，真实标签数据应包括图像中物体的类别以及该图像中每个物体的真实边界框。 鉴别正确的检测结果并计算precision和recall 首先需得到True Positives、False Positives、True Negatives、False Negatives。 为了得到TP和FP，需要使用IoU，即预测框与ground truth的交集与并集之比，从而确定一个检测结果是正确的还是错误的。最常用的阈值为0.5，即IoU&gt;0.5，认为是TP，否则FP（当然在一些数据集的评估指标中常采用不同的阈值）。 计算Recall需要得到负样本的数量，但由于图片中并未预测到物体的每个部分都视作Negative，故很难得到TN。但可以只计算FN，即模型漏检的物体数。 另一个需要考虑的是模型所给出的各个检测结果的置信度。通过改变置信度阈值可以改变一个预测框是属于Positive还是Negative。阈值以上的所有预测（Box + Class）均被认为是Positve。 对于每一张图片，ground truth数据会给出图片中各个类别的实际物体数，计算每个Positive预测框与ground truth的IoU，并取值最大的预测框。然后根据IoU阈值，可以得到各个类别的TP和FP。由此，可计算出各个类别的precision。 由TP，可以计算得到漏检的物体数，即FN。由此，可以计算出各个类别的recall。 计算mAP mAP有许多不同的定义，在这里以PASCAL VOC竞赛的评估指标为例。 在这里，可以注意到，至少有两个变量会影响precision和recall，即IoU和置信度阈值。在PASCAL VOC竞赛中，IoU采用0.5。但置信度在不同模型中差异较大，会导致precision-recall曲线变化。于是，他们提出计算AP的一种方法。 首先对模型预测结果进行排序，按预测值置信度降序，给定一个rank，recall和precision仅在高于该rank值的预测结果中进行计算。改变rank会导致recall值的变化，共选择11个不同的recall值，分别为0,0.1,0.2,…,1.0，可认为选择了11个rank。由于按照置信度排序，实际就等价于选择了11个置信度阈值。 另外，在计算precision时，采用了插值的方法，对于某个recall值r，precision值取所有recall&gt;=r中的最大值，以保证PR曲线是单调递减的，减少由于样本排序中小的变化引起的PR曲线的抖动。AP就定义为在这11个recall下的precision的平均值，表征整个precision-recall曲线，也就是曲线下的面积。average是对recall取平均，mean是对所有类别取平均（每一个类别当做一次二分类任务）。 对于各个类别，用上述方法计算AP，求所有类别平均即得到mAP。在COCO数据集中，采用的是更严格的计算方式，计算了不同IoU阈值和物体大小下的AP(详情见COCO Detection Evaluation)。 举个例子加深自己的理解： 一个二分类问题，每个类分别五个样本，如果分类器性能足够好的话，那么根据预测的置信度降序排序，ranking结果应该是+1, +1, +1, +1, +1, -1, -1, -1, -1, -1。然而实际情况中，分类器预测的label和score都不可能如此完美；按score降序，加入根据给定的rank值，选择了前四个score(这个置信分数可能由softmax、SVM等方式计算得到)，认为这四个是正样本，由此来计算recall和precision。而实际上这四个样本中只有两个是正样本，那么此时的recall=2(选择中包含的正样本数)/5(总共的正样本数)=0.4，precision=2(选择中的正样本数)/4(认为是正样本的个数)=0.5。 可以看出，recall和precision均和rank值有关，也就是由此选择前k个样本，关于k的函数。那么根据rank取值的不同，这里总共可以计算10对precision-recall值，recall依次为为1/，将它们画出来，得到的就是PR曲线。 观察可以得到PR曲线的一个趋势就是，recall值越高，precision就越低。假如我选择所有样本来计算，那么当然包括了所有的正样本，此时的recall=1(此处认为ground truth所有框均被检测出来。这里有个问题需要思考下，在实际的目标检测问题中，是根据检测出的bbox来计算其与ground truth的IoU以判断bbox是否为正确检测，这样判定出的正确样本数为bbox的数量，往往不等于ground truth的数量；不过bbox的数量是需要经过NMS处理的，处理后基本与检测的目标数差不太多，)，precision就等于所有样本中正样本占比，当负样本占比很大时，那么precision就很小了。 内容参考：博客：Measuring Object Detection models - mAP - What is Mean Average Precision?代码：VOC数据集的mAP实现、COCO数据集mAP计算API论文：End-to-end training of object class detectors for mean average precision]]></content>
  </entry>
  <entry>
    <title><![CDATA[感受野（Receptive Field）]]></title>
    <url>%2F2018%2F11%2F23%2FReceptiveField%2F</url>
    <content type="text"><![CDATA[之前一直不是很理解感受野是什么，因此认真地看了下相关知识，在这里记录一下~ 感受野，指的是一个特定的CNN特征在输入空间所受影响的区域，可以用中心位置(center location)和大小(size)来表征；用来表示网络内部不同神经元对原图像的感受范围大小，也就是CNN每一层输出的特征图（feature map）上的像素点在原始图像上映射的区域大小。 由于网络结构中普遍使用卷积层和池化层，层与层之间均通过sliding filter进行局部相连，所以每一个神经元都无法对原始图像的所有信息进行感知。而感受野越大，表示该神经元所能接触到的原始图像范围越大，也就意味着更可能蕴含全局、语义层的深层特征；感受野越小则表示其所包含的特征更趋向于局部、浅层的细节特征。 感受野的大小可以用来判断网络每一层的抽象层次。 输入层每个单元的感受野是1，层次越深，感受野越大，是由kernel size和stride size共同决定的。而对于深度CNN，我们无法直接追踪到感受野信息。 感受野中心位置及大小计算具体公式推导及代码参考：A guide to receptive field arithmetic for Convolutional Neural Networks 对于一个CNN特征来说，感受野中的每个像素值并不是同等重要。一个像素点越接近感受野中心，它对输出特征的计算所起作用越大，这意味着某一个特征不仅仅是受限在输入图片某个特定的区域，而且呈指数级聚焦在区域的中心。]]></content>
  </entry>
  <entry>
    <title><![CDATA[目标检测学习之路]]></title>
    <url>%2F2018%2F11%2F20%2Fobject_dection%2F</url>
    <content type="text"><![CDATA[未写完… 最近为了做毕设，重新开始看目标检测相关的一系列论文，在这里记录一下自己的学习过程，也方便以后复习。 R-CNN / 2013.11论文：Rich feature hierarchies for accurate object detection and semantic segmentation Ross Girshick等人发表的这篇文章，首次将卷积神经网络用于「目标检测」，从这以后才有越来越多人将深度学习用于该问题，所以该论文意义深远。 主要解决了传统方法的两个问题： 1. 速度R-CNN使用启发式方法（Selective Search) ，先生成候选区域再检测，降低信息的冗余度，从而提高了检测速度。 2. 特征提取传统的手工提取，特征仅限于低层次的颜色、纹理等，故效果差。 SPP-Net / 2014.6论文：Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition 在R-CNN提出半年后，何恺明等人提出了SPP-Net。 R-CNN中存在两个比较大的问题，SPP-Net就解决了这两个问题：1. 算力冗余先生成候选区域，再对区域进行卷积，这使得候选区域会有一定程度上的重叠，对相同的区域进行重复的卷积，而每个区域进行新的卷积还需要新的存储空间。 SPP-Net对此进行了优化，将先生成候选区域再卷积，改为先卷积再生成候选区域。这样，不仅减少了存储量而且加快了训练速度。 2. 图片的裁剪与缩放在SPP-Net之前，所有的神经网络都是需要输入固定尺寸的照片，比如224*224（ImageNet）、32*32(LenNet)等。这样当我们希望检测各种大小的图片时，需要经过crop，或者warp等一系列操作，这都在一定程度上导致图片信息的丢失和变形，限制了识别精确度。而且，从生理学角度出发，人眼看到一个图片时，大脑会首先认为这是一个整体，而不会进行crop和warp，所以更有可能的是，我们的大脑通过搜集一些浅层的信息，在更深层才识别出这些任意形状的目标。 为什么需要固定输入图片的大小？ 卷积层的参数和输入大小无关，它仅是一个卷积核在图像上滑动，对不同大小的图片卷积得到不同大小的特征图（feature map)；但是全连接层（FC Layer）情况则不一样。由于全连接层把输入的所有像素点连接起来，需要指定输入层神经元个数和输出层神经元个数，所以必须规定输入的特征图大小，以指定参数个数。 SPP-Net解决方法 SPP-Net在最后一个卷积层后，接入了金字塔池化（spatial pyramid pooling)层，使用这种方式，可以让网络输入任意的图片，而且还会生成固定大小的输出。 什么是金字塔池化？从图中分析，黑色图片代表Conv5之后的feature map，其大小任意。接着以不同大小的块来提取特征，分别是4*4，2*2，1*1，将这三张网格放到下面这张特征图上，就可以得到16+4+1=21种不同的块(Spatial bins)，我们从这21个块中，每个块提取出一个特征，这样刚好就是我们要提取的21维特征向量。这种以不同的大小格子的组合方式来池化的过程就是空间金字塔池化（SPP）。如果要进行空间金字塔最大池化，就是从这21个图片块中，分别计算每个块的最大值，从而得到一个21维特征的输出单元。共用256个滤波器，最终输出向量大小固定为bins*filters，即（16+4+1)*256，作为全连接层的输入。 总的来说，金字塔池化意义在于多尺度特征提取出固定大小的特征向量。 Fast R-CNN / 2015.4论文：Fast R-CNN Ross Girshick在R-CNN之后，再次提出了Fast R-CNN，该论文中引用了SPP-Net的工作，相对于之前的R-CNN所做的最大优化就是快。 将原来的串行结构改成并行结构]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
